---
id: isAllOf
title: isAllOf
sidebar_label: isAllOf
hide_title: true
---

# `isAllOf`

A higher-order function that accepts several type guard functions or `redux-toolkit` action creator functions and
returns a type guard function that matches (returns true) if *all* of the provided functions match.  Action creator
functions include the ones produced by `createAction` or the child actions of an async thunk produced by
`createAsyncThunk`, such as `asyncThunk.pending`, `asyncThunk.fulfilled`, and `asyncThunk.rejected`.

```js
function isAllOf(...matchers)
```

## Simplifying matchers

When constructing a reducer, you may need to handle a single action differently based on more detailed characteristics.
This can make reducers for a particular case more complicated than necessary.

```ts
import { createAsyncThunk, createReducer, PayloadAction } from '@reduxjs/toolkit'

interface Data {
  isInteresting: boolean;
  isSpecial: boolean;
}

interface Special extends Data {
  isSpecial: true;
}

interface Interesting extends Data {
  isInteresting: true;
}

function isSpecial(action: PayloadAction<Data>): action is PayloadAction<Special> {
  return action.payload.isSpecial;
}

function isInteresting(action: PayloadAction<Data>): action is PayloadAction<Interesting> {
  return action.payload.isInteresting;
}

interface ExampleState {
  isSpecial: boolean;
  isInteresting: boolean;
}

const initialState: ExampleState = {
  isSpecial: false,
  isInteresting: false,
}

const request = createAsyncThunk('request', () => {
  return {
    isSpecial: true,
    isInteresting: true,
  };
});

const loadingReducer = createReducer(initialState, builder => {
  builder
    .addCase(request.fulfilled, (state, action) => {
      if (isSpecial(action)) {
        return {
          ...state,
          isSpecial: true,
        }
      } else if (isInteresting(action)) {
        return {
          ...state,
          isInteresting: true,
        }
      }
    });
});
```

With isAllOf, we can use matchers to reorganize that code into a more canonical form.
And more importantly, it enables more complex cases to be handled straightforwardly.

```ts
import { createAsyncThunk, createReducer, PayloadAction, isAllOf } from '@reduxjs/toolkit'

interface Data {
  isInteresting: boolean;
  isSpecial: boolean;
}

interface Special extends Data {
  isSpecial: true;
}

interface Interesting extends Data {
  isInteresting: true;
}

function isSpecial(action: PayloadAction<Data>): action is PayloadAction<Special> {
  return action.payload.isSpecial;
}

function isInteresting(action: PayloadAction<Data>): action is PayloadAction<Interesting> {
  return action.payload.isInteresting;
}

interface ExampleState {
  isSpecial: boolean;
  isInteresting: boolean;
}

const initialState: ExampleState = {
  isSpecial: false,
  isInteresting: false,
}

const request = createAsyncThunk('request', () => {
  return {
    isSpecial: true,
    isInteresting: true,
  };
});

const loadingReducer = createReducer(initialState, builder => {
  builder
    .addMatcher(isAllOf(request.fulfilled, isSpecial), (state, action) => {
      return {
        ...state,
        isSpecial: true,
      }
    })
    .addMatcher(isAllOf(request.fulfilled, isInteresting), (state, action) => {
      return {
        ...state,
        isInteresting: true,
      }
    });
})
```
