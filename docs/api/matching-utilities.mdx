---
id: matching-utilities
title: Matching Utilities
sidebar_label: Matching Utilities
hide_title: true
---

# Matching Utilities

Redux Toolkit exports a couple of type-safe utility matchers that you can leverage to simplify your code.

- [`isAllOf`](#isallof) - returns true when **all** conditions are met
- [`isAnyOf`](#isanyof) - returns true when at least one of the conditions are met

## `isAllOf`

A higher-order function that accepts one or more of:

- `redux-toolkit` action creator functions such as the ones produced by:
  - [`createAction`](./createAction)
  - [`createSlice`](./createSlice#return-value)
  - [`createAsyncThunk`](./createAsyncThunk#promise-lifecycle-actions)
- type guard functions
- custom action creator functions that have a `.match` property that is a type guard

It will return a type guard function that returns `true` if _all_ of the provided functions match.

## `isAnyOf`

Accepts the same inputs as `isAllOf` and will return a type guard function that returns `true` if at least one of the provided functions match.

## Using matchers to reduce code complexity, duplication and boilerplate

When using the `builder` pattern to construct a reducer, we add cases or matchers one at a time. However, by using `isAnyOf` or `isAllOf`,
we're able to easily use the same matcher for several cases in a type-safe manner.

First, let's examine an unnecessarily complex example:

```ts title="Example without using a matcher utility"
import {
  createAsyncThunk,
  createReducer,
  PayloadAction
} from '@reduxjs/toolkit'

interface Data {
  isInteresting: boolean
  isSpecial: boolean
}

interface Special extends Data {
  isSpecial: true
}

interface Interesting extends Data {
  isInteresting: true
}

function isSpecial(
  action: PayloadAction<Data>
): action is PayloadAction<Special> {
  return action.payload.isSpecial
}

function isInteresting(
  action: PayloadAction<Data>
): action is PayloadAction<Interesting> {
  return action.payload.isInteresting
}

interface ExampleState {
  isSpecial: boolean
  isInteresting: boolean
}

const initialState: ExampleState = {
  isSpecial: false,
  isInteresting: false
}

const request = createAsyncThunk('request', () => {
  return {
    isSpecial: true,
    isInteresting: true
  }
})

// This has unnecessary complexity
const loadingReducer = createReducer(initialState, builder => {
  builder.addCase(request.fulfilled, (state, action) => {
    if (isSpecial(action)) {
      state.isSpecial = true
    } else if (isInteresting(action)) {
      state.isInteresting = true
    }
  })
})
```

In this scenario, we can use `isAllOf` to simplify our code and reduce some of the boilerplate.

```ts title="Refactoring with isAllOf"
import { createReducer, isAllOf } from '@reduxjs/toolkit'
import {
  request,
  initialState,
  isSpecial,
  isInteresting,
  Data
} from '@virtual/matchers' // This is a fake pkg that provides the types shown above

const loadingReducer = createReducer(initialState, builder => {
  builder
    .addMatcher(isAllOf(request.fulfilled, isSpecial), (state, action) => {
      state.isSpecial = true
    })
    .addMatcher(isAllOf(request.fulfilled, isInteresting), (state, action) => {
      state.isInteresting = true
    })
})
```

## Using matchers as a TypeScript Type Guard

The function returned by `isAllOf` and `isAnyOf` can also be used as a TypeScript type guard in other contexts.

```ts title="Using isAllOf as a type guard"
import { isAllOf, PayloadAction } from '@reduxjs/toolkit'
import { request, Data, isSpecial, isInteresting } from '@virtual/matchers' // This is a fake pkg that provides the types shown above

const isSpecialAndInteresting = isAllOf(isSpecial, isInteresting)

function someFunction(action: PayloadAction<Data>) {
  if (isSpecialAndInteresting(action)) {
    // "action" will be correctly typed as:
    // `PayloadAction<Special> & PayloadAction<Interesting>`
  }
}
```

```ts title="Using isAnyOf as a type guard"
import { isAnyOf, PayloadAction } from '@reduxjs/toolkit'
import { request, Data, isSpecial, isInteresting } from '@virtual/matchers' // this is a fake pkg that provides the types shown above

const isSpecialOrInteresting = isAnyOf(isSpecial, isInteresting)

function someFunction(action: PayloadAction<Data>) {
  if (isSpecialOrInteresting(action)) {
    // "action" will be correctly typed as:
    // `PayloadAction<Special> | PayloadAction<Interesting>`
  }
}
```
